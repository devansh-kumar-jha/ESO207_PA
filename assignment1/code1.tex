\documentclass[20pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[ruled, lined, linesnumbered, commentsnumbered, longend]{algorithm2e}
\usepackage{xcolor}

\title{Question 1}
\author{Devansh Kumar Jha}
\date{2021–08–30}

\begin{document}
\maketitle

\section{Programming problem 1}

\subsection{Problem Description}
We are required to add the polynomials according to the given input where we are first given two integers n and m which are followed by {2n} and {2m} integers in the next two lines.
The main complexities and boundary cases in the problem were to design a {O(m+n)} algorithm and to recognize that zero polynomials are the exceptional cases which do not directly fit into the algorithm and so are to be specifically handled. To take care of integer overflow we by default use big integers as our storage containers.

\subsection{Data Structure Usage}
We will be using a dynamically allocated doubly linked list with a sentinel node for easier and error free implementation.

\subsection{Algorithm Explanation}
The algorithm is quite simple. We just take two temprorary node pointers which will correspond to the current term of that particular polynomial in the addition process. There are 3 major cases as follows -

\begin{itemize}
\item \textbf{1st polynomial already traversed}
\\
In this case we just add the term of 2nd polynomial to the answer polynomials doubly linked list. Here we don't need to check anything as the question statement says that the coefficients will anyways be non-zero.

\item \textbf{2nd polynomail already traversed}
\\
Similar to the case above with the difference that this time we will be traversing the 1st polynomial and adding new nodes to the resultant polynomial.

\item \textbf{Both polynomials are being traversed}
\\
This is the most complex case of the mentioned three with some exceptions to be handled within. While we are simultaneously traversing the 1st and 2nd polynomial the currently checked term might have different variable exponents. In that case we cannot add them and we simply need to add one of them to the list. We chose to add the element with smaller exponent into the list as it ensures the automatic sorting of the resultant polynomial.
In case of the exponents being equal we need to confirm that the coefficients don't add to zero. In case they do than we just skip these terms however if not than we add them.
So it can easily be seen that in this case the iteration would be a bit more costly as compared 1st and 2nd case iteration.
\end{itemize}

\subsection{Pseudo Code}
These are the variables used - 
\begin{itemize}
\item \textbf{HEAD}   - The first element of addition polynomial.
\item \textbf{HEAD1} - The first element of first polynomial.
\item \textbf{HEAD2} - The first element of second polynomial.
\item \textbf{SENT}   - Sentinel node for addition polynomial.
\end{itemize}
\textbf{**} - Similar goes for {TAIL,TAIL1,TAIL2,SENT1,SENT2}

\newcommand\mycommfont[1]{\small\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\begin{algorithm}

	\SetKwFunction{isOddNumber}{isOddNumber}
	\SetKwInOut{KwIn}{Input}
	\SetKwInOut{KwOut}{Output}

	\KwIn{The two linked lists showing p(x) and q(x) and pointers to make output polynomial r(x)}
	\KwOut{No output}
	
	$temp1 = HEAD1$ and $temp2 = HEAD2$ \\
	\tcc{Temprorary pointers to traverse along the available polynomials.}	

	\While{$temp1 != SENT1$ or $temp2 != SENT2$} {
		\eIf{$temp1 == SENT1$} {
			$TAIL.insert-node(temp2)$  \tcp*[f]{insert-node() is a function which makes a new node and adds to the list}
			$temp2 \leftarrow (temp2 \rightarrow next)$
		} {   \eIf{$temp2 == SENT2$} {
					$TAIL.insert-node(temp1)$ \\
					$temp1 \leftarrow (temp1 \rightarrow next)$
				} {
					\eIf{$temp1 \rightarrow exp == temp2 \rightarrow exp$} {
							\eIf{$temp1 \rightarrow cof != temp2 \rightarrow cof$} {
									a=make-node($temp1 \rightarrow cof + temp2 \rightarrow cof$,$temp1 \rightarrow exp$)
									\tcc{make-node() function allocates memory for a new node and fills with the parameters given}
									$TAIL.insert-node(a)$
							} { } 
							$temp1 \leftarrow (temp1 \rightarrow next)$ \\
							$temp2 \leftarrow (temp2 \rightarrow next)$
					} {
							\eIf{$temp1 \rightarrow exp < temp2 \rightarrow exp$} {
								$TAIL.insert-node(temp1)$ \\	
								$temp1 \leftarrow (temp1 \rightarrow next)$
							} {
								$TAIL.insert-node(temp2)$ \\
								$temp2 \leftarrow (temp2 \rightarrow next)$	
							}	
					}
				}
		}
	}
	\KwRet{}
	\caption{List Making Algorithm}	

\end{algorithm}

\end{document}
