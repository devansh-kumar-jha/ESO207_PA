\documentclass[20pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[ruled, lined, linesnumbered, commentsnumbered, longend]{algorithm2e}
\usepackage{xcolor}

\title{Question 2}
\author{Divyansh Gupta}
\date{2021–08–30}

\begin{document}
\maketitle

\section{Programming problem 2}

\subsection{Problem Description}
We are required to multiply the polynomials according to the given input where we are first given two integers n and m which are followed by {2n} and {2m} integers in the next two lines.
The main complexities and boundary cases in the problem were to design a {O(mn)} algorithm and to recognize that zero polynomials are the exceptional cases which do not directly fit into the algorithm and so are to be specifically handled. To take care of integer overflow we by default use big integers as our storage containers.

\subsection{Data Structure Usage}
We will be using a dynamically allocated doubly linked list with a sentinel node for easier and error free implementation.

\subsection{Algorithm Explanation}
The algorithm is quite simple. We first allocate nodes to the answer list starting from lowest exponent to highest exponent with coefficient=0. Then we take two temporary node pointers which will traverse through the polynomial and for each term of the first polynomial the 2nd pointer will traverse through the whole 2nd polynomial and hence the complexity {O(mn)}.Though this is just a approximate analysis and a detailed analysis follows below.

\subsection{Pseudo Code}
These are the variables used - 

\begin{itemize}
\item \textbf{HEAD}   - The first element of answer polynomial.
\item \textbf{HEAD1} - The first element of first polynomial.
\item \textbf{HEAD2} - The first element of second polynomial.
\item \textbf{SENT}   - Sentinel node for answer polynomial.
\end{itemize}
\textbf{**} - Similar goes for {TAIL,TAIL1,TAIL2,SENT1,SENT2}

\newcommand\mycommfont[1]{\small\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\begin{algorithm}

	\SetKwFunction{isOddNumber}{isOddNumber}
	\SetKwInOut{KwIn}{Input}
	\SetKwInOut{KwOut}{Output}

	\KwIn{The two linked lists showing p(x) and q(x) and pointers to make output polynomial r(x)}
	\KwOut{No output}

    $less = HEAD1 \rightarrow exp + HEAD2 \rightarrow exp$,$more = TAIL1 \rightarrow exp + TAIL2 \rightarrow exp$ \\
    \For{$i \leftarrow less$ \KwTo $more$} {
			$TAIL.insert-node($0$,$i$)$
	}

    $temp1 = HEAD1$  \tcp{This is the temprorary node pointer which will help us to traverse through the 1st array}
    \While{$temp1 != SENT1$}{
        $temp2 = HEAD2$, $temp=HEAD$ \\
		\tcc{These are the temprorary node pointers to traverse through the 2nd polynomial and the resultant polynomial}
        \While{$temp2 != SENT2$}{
            $find = temp1 \rightarrow exp + temp2 \rightarrow exp$ \\
            \While{$temp != SENT$ and $temp \rightarrow exp != find$} {
                $temp \leftarrow (temp \rightarrow next)$
			  \tcc{We are trying to find the appropriate place for the product to be added in the resultant.}
            }
            $(temp \rightarrow cof) \leftarrow ( temp \rightarrow cof ) + (temp1 \rightarrow cof * temp2 \rightarrow cof)$
            $temp2 \leftarrow (temp2 \rightarrow next)$
        }
        $temp1 \leftarrow (temp1 \rightarrow next)$
    }

    $temp = HEAD$ \\
	
	\tcc{Now we will adjust the HEAD and TAIL of resultant polynomial and than remove all nodes containing zero values}
     \If{$HEAD \rightarrow cof == 0$} {
	    $HEAD \leftarrow (HEAD \rightarrow next)$ \\
     }
     \If{$TAIL \rightarrow cof == 0$} {
		$TAIL \leftarrow (TAIL \rightarrow prev)$
	}
            
     \While{$temp != SENT$}{
        \eIf{$temp \rightarrow cof == 0$} {
        			remove(temp)         \tcp*[f]{remove() is just a series of 3 to 4 steps in which the particular pointed element is deleted}
		} { }
 		$temp \leftarrow (temp \rightarrow next)$
     }
     
     \KwRet{}
	\caption{List Making Algorithm}	

\end{algorithm}

\subsection{Runtime Analysis}
The exact runtime analysis would be quite difficult in the algorithm we have implemented so rather we would do some approximate runtime analysis of the code.
So we take the following quite logical and practically appropriate assumptions -

\begin{itemize}
\item \textbf{The length of empty list created} is approximately equal to \textbf{m+n}. This basically implies that there are no large gaps in the exponents provided to us and they stand all nearly at some distance to each other. There might be some terms which contribute to a single exponent also so the value of actual length can be sometimes less than (m+n) also.
\item \textbf{The cost of each iteration of the algorithm while calculating the result} is approximately equal to each other except for the innermost loop which tries to find the exponent where the values are to be added in empty list.
\end{itemize}

So with these assumptions we can conclude that -
\begin{itemize}
\item \textbf{The first for loop} \\
Will have a total of (m+n) iterations with some constant time owing to total \\
\textbf{$ time = c_1(m+n) $}

\item \textbf{The main nested loop set} \\
Will have a outer loop running n times and a inner loop running m times. The cost of each iteration of the inner loop will be $ time_{ji} = c_2 + c_3x_i $  where  $[x_i]$ for $ 1 <= i <= m$ would be the number of iteration of the tiny loop iterating over the resultant polynomial. Here j is the index for outer loop $ 1 <= j <= n $. \\
It could be easily seen that  $ \sum _{i=1}^{m} {x_i} = (m+n) $ thus the total cost of all iterations  i.e. $ time_j = \sum _{i=1}^{m} {time_i} = c_2m + c_3(m+n) $.
Adding over all the times we get  \\
\textbf{$ time = c_4mn + c_5n^2$}

\item \textbf{Zero clearing for loop} \\
This also iterates over the (m+n) elements and delete the nodes with coefficient as zero.So \\
\textbf{$ time = c_6(m+n) $}
\end{itemize}

Totalling all the costs of all steps we get
\begin{equation} runtime = c^{'}(m+n) + c^{''}mn + c^{'''}n^2 \end{equation}
\begin{equation} runtime <= cmn \end{equation}

For some sufficiently large value of constant we can say that the terms $ mn $ and $ n^2 $  are of the same order and thus we choose convert it in form of $ mn $ as it is a more useful notation. \\
\textbf{So the algorithm is having a time complexity of $ \textbf{O(m*n)} $}

\end{document}
